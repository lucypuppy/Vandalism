/*
 * This file is part of Vandalism - https://github.com/NekosAreKawaii/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, FooFieOwO, Recyz and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit.disabler.impl;

import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.event.game.WorldListener;
import de.nekosarekawaii.vandalism.event.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.event.player.PlayerUpdateListener;
import de.nekosarekawaii.vandalism.feature.module.impl.exploit.disabler.DisablerModule;
import de.nekosarekawaii.vandalism.feature.module.template.module.ModuleMulti;
import de.nekosarekawaii.vandalism.util.PacketHelper;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.network.packet.c2s.query.QueryPingC2SPacket;

import java.util.concurrent.ConcurrentHashMap;

public class CubeCraftModuleMode extends ModuleMulti<DisablerModule> implements OutgoingPacketListener, PlayerUpdateListener, WorldListener {

    private final ConcurrentHashMap<Packet<?>, Long> packets = new ConcurrentHashMap<>();
    private int positivePong, negativePong, ticks;
    private Packet<?> lastPacket = null;

    public CubeCraftModuleMode() {
        super("CubeCraft");
    }

    @Override
    public void onOutgoingPacket(OutgoingPacketEvent event) {
        if (mc.getNetworkHandler() == null || mc.getNetworkHandler().getConnection() == null || mc.player == null) {
            packets.clear();
            return;
        }

        if (event.packet instanceof final CommonPongC2SPacket packet) {
            if (packet.getParameter() < 0) {
//                ChatUtil.chatMessage("Last negative pong: " + negativePong);
                negativePong = packet.getParameter();
//                ChatUtil.chatMessage("Last packet: " + lastPacket.getClass().getSimpleName());
//                ChatUtil.chatMessage("Negative pong: " + negativePong);
            } else if (positivePong <= 0) {
                positivePong = packet.getParameter();
            }

            event.cancel();
        }

        if (event.packet instanceof KeepAliveC2SPacket || event.packet instanceof QueryPingC2SPacket) {
            if (negativePong < 0) {
                negativePong++;
//                PacketHelper.sendImmediately(new CommonPongC2SPacket(negativePong), null, true);
                packets.put(new CommonPongC2SPacket(negativePong), System.currentTimeMillis());
            }
            packets.put(event.packet, System.currentTimeMillis());
            event.cancel();
        }

        if (event.packet instanceof PlayerMoveC2SPacket) {
            if (negativePong < 0) {
//                negativePong++;
                PacketHelper.sendImmediately(new CommonPongC2SPacket(negativePong), null, true);
            }
        }

        if (lastPacket != null) {
            if (lastPacket instanceof PlayerMoveC2SPacket) {
                if (negativePong < 100 && negativePong % 2 == 0) {
                    PacketHelper.sendImmediately(new CommonPongC2SPacket(negativePong), null, true);
                }
            }
        }

//        if (event.packet instanceof PlayerMoveC2SPacket || event.packet instanceof KeepAliveC2SPacket)
        lastPacket = event.packet;
    }

    @Override
    public void onPrePlayerUpdate(PlayerUpdateEvent event) {
        ticks++;

        if (positivePong > 100 && ticks > 250) {
            positivePong++;
            if (positivePong % 2 == 0) {
                PacketHelper.sendImmediately(new CommonPongC2SPacket(positivePong), null, true);
                ticks = 0;
            }
        }

        for (final Packet<?> packet : packets.keySet()) {
            if (System.currentTimeMillis() - packets.get(packet) >= 10000) { // 5000
                packets.remove(packet);
                PacketHelper.sendImmediately(packet, null, true);
            }
        }
    }

    @Override
    public void onPreWorldLoad() {
        positivePong = -1;
        negativePong = 1;
    }

    @Override
    public void onActivate() {
        positivePong = -1;
        negativePong = 1;
        Vandalism.getInstance().getEventSystem().subscribe(this, OutgoingPacketEvent.ID, PlayerUpdateEvent.ID, WorldLoadEvent.ID);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(this, OutgoingPacketEvent.ID, PlayerUpdateEvent.ID, WorldLoadEvent.ID);
    }

}
