package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import de.florianmichael.rclasses.math.Percentage;
import de.florianmichael.rclasses.math.integration.MSTimer;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.event.game.TickGameListener;
import de.nekosarekawaii.vandalism.base.event.network.IncomingPacketListener;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.util.minecraft.ChatUtil;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
import net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;
import java.util.List;

public class NoComModule extends AbstractModule implements TickGameListener, IncomingPacketListener {

    private final IntegerValue maxPacketsPerTick = new IntegerValue(
            this,
            "Max Packets Per Tick",
            "The maximum amount of packets sent per tick.",
            1,
            1,
            10000
    );

    private final IntegerValue delay = new IntegerValue(
            this,
            "Delay",
            "The delay between packets.",
            0,
            0,
            2000
    );

    private final IntegerValue startX = new IntegerValue(
            this,
            "Start X",
            "The X coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue startY = new IntegerValue(
            this,
            "Start Y",
            "The Y coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue startZ = new IntegerValue(
            this,
            "Start Z",
            "The Z coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue endX = new IntegerValue(
            this,
            "End X",
            "The X coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final IntegerValue endY = new IntegerValue(
            this,
            "End Y",
            "The Y coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final IntegerValue endZ = new IntegerValue(
            this,
            "End Z",
            "The Z coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final MSTimer delayTimer = new MSTimer();

    private final List<BlockPos> possibleBlockPositions = new ArrayList<>();
    private int lastChecked = -2;

    private Thread scanThread = null;

    public NoComModule() {
        super(
                "No Com",
                "This module allows you to find loaded chunks on the server. (Vanilla/Spigot)",
                Category.EXPLOIT
        );
        this.disableAfterSession();
    }

    private void reset() {
        this.lastChecked = -2;
        this.possibleBlockPositions.clear();
        try {
            if (this.scanThread != null) {
                this.scanThread.interrupt();
                this.scanThread.stop();
                this.scanThread = null;
            }
        } catch (Exception ignored) {
        }
    }

    @Override
    public void onActivate() {
        this.reset();
        this.scanThread = new Thread(() -> {
            ChatUtil.warningChatMessage("No Com: Started thread to add all possible block positions to the list.");
            for (int currentX = this.startX.getValue(); currentX < this.endX.getValue(); currentX++) {
                for (int currentY = this.startY.getValue(); currentY < this.endY.getValue(); currentY++) {
                    for (int currentZ = this.startZ.getValue(); currentZ < this.endZ.getValue(); currentZ++) {
                        this.possibleBlockPositions.add(new BlockPos(currentX, currentY, currentZ));
                    }
                }
            }
            ChatUtil.infoChatMessage("No Com: Finished adding all possible block positions to the list.");
            this.lastChecked = -1;
        });
        this.scanThread.start();
        Vandalism.getInstance().getEventSystem().subscribe(TickGameEvent.ID, this);
        Vandalism.getInstance().getEventSystem().subscribe(IncomingPacketEvent.ID, this);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(TickGameEvent.ID, this);
        Vandalism.getInstance().getEventSystem().unsubscribe(IncomingPacketEvent.ID, this);
        this.reset();
    }

    @Override
    public void onTick() {
        if (this.mc.player == null || this.lastChecked == -2) return;
        if (this.delayTimer.hasReached(this.delay.getValue(), true)) {
            for (int i = 0; i < this.maxPacketsPerTick.getValue(); i++) {
                this.lastChecked++;
                if (this.lastChecked >= this.possibleBlockPositions.size()) {
                    this.reset();
                    ChatUtil.infoChatMessage("No Com: Finished with checking all possible block positions.");
                    this.deactivate();
                    break;
                }
                final BlockPos blockPos = this.possibleBlockPositions.get(this.lastChecked);
                ChatUtil.infoChatMessage("No Com: " + blockPos.toShortString() + " | " + Percentage.percentage(this.lastChecked, this.possibleBlockPositions.size()) + "%");
                final String text = "";
                this.mc.getNetworkHandler().getConnection().send(new UpdateSignC2SPacket(blockPos, true, text, text, text, text), null, true);
            }
        }
    }

    @Override
    public void onIncomingPacket(final IncomingPacketEvent event) {
        if (this.lastChecked == -2) return;
        if (event.packet instanceof final BlockEntityUpdateS2CPacket blockEntityUpdateS2CPacket) {
            if (blockEntityUpdateS2CPacket.getBlockEntityType().getRegistryEntry().equals(BlockEntityType.SIGN.getRegistryEntry())) {
                final NbtCompound nbt = blockEntityUpdateS2CPacket.getNbt();
                if (!nbt.isEmpty()) {
                    final StringBuilder text = new StringBuilder();
                    text.append(" (");
                    text.append(blockEntityUpdateS2CPacket.getPos().toShortString());
                    text.append(")");
                    text.append(" [");
                    if (nbt.contains("back_text")) {
                        final NbtCompound backText = nbt.getCompound("back_text");
                        if (backText.contains("messages")) {
                            final NbtList messages = backText.getList("messages", 8);
                            text.append("Back Messages: ");
                            for (int i = 0; i < messages.size(); i++) {
                                final String message = messages.getString(i);
                                text.append(message);
                                if (i != messages.size() - 1) {
                                    text.append(", ");
                                }
                            }
                            text.append(" | ");
                        }
                    }
                    if (nbt.contains("front_text")) {
                        final NbtCompound frontText = nbt.getCompound("front_text");
                        if (frontText.contains("messages")) {
                            final NbtList messages = frontText.getList("messages", 8);
                            text.append("Front Messages: ");
                            for (int i = 0; i < messages.size(); i++) {
                                final String message = messages.getString(i);
                                text.append(message);
                                if (i != messages.size() - 1) {
                                    text.append(", ");
                                }
                            }
                        }
                    }
                    text.append("]");
                    ChatUtil.infoChatMessage("Found loaded sign: " + text);
                }
            }
        }
    }

}
