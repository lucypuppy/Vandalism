/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, Verschlxfene, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import de.florianmichael.dietrichevents2.Priorities;
import de.florianmichael.rclasses.common.RandomUtils;
import de.florianmichael.rclasses.math.timer.MSTimer;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.event.cancellable.network.IncomingPacketListener;
import de.nekosarekawaii.vandalism.event.cancellable.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.event.normal.network.WorldListener;
import de.nekosarekawaii.vandalism.event.normal.player.PlayerUpdateListener;
import de.nekosarekawaii.vandalism.event.normal.render.Render3DListener;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.BooleanValue;
import de.nekosarekawaii.vandalism.base.value.template.ValueGroup;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.util.game.PacketUtil;
import net.minecraft.client.render.Tessellator;
import net.minecraft.client.render.VertexConsumerProvider;
import net.minecraft.client.render.debug.DebugRenderer;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.entity.TrackedPosition;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
import net.minecraft.network.packet.s2c.play.PlayerRespawnS2CPacket;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Vec3d;

import java.util.concurrent.ConcurrentLinkedQueue;

public class FakeLagModule extends AbstractModule implements PlayerUpdateListener, IncomingPacketListener, OutgoingPacketListener, Render3DListener, WorldListener {

    public final IntegerValue packetDrop = new IntegerValue(
            this,
            "Packet Drop",
            "The amount of time in milliseconds to delay packets.",
            60,
            0,
            1000);

    private final IntegerValue packetDelay = new IntegerValue(
            this,
            "Packet Delay",
            "The amount of time in milliseconds to delay packets.",
            60,
            0,
            1000);

    private final IntegerValue dropPacketChance = new IntegerValue(
            this,
            "Drop Packet Chance",
            "The chance of dropping a packet.",
            10,
            0,
            100);

    private final IntegerValue duplicatePacketChance = new IntegerValue(
            this,
            "Duplicate Packet Chance",
            "The chance of duplicating a packet.",
            10,
            0,
            100);

    private final ValueGroup resyncGroup = new ValueGroup(this, "Resync", "Resync options.");

    private final BooleanValue resyncOnDamage = new BooleanValue(
            this.resyncGroup,
            "Resync on Damage",
            "Resync if you take damage.",
            true);

    private final IntegerValue resyncHurtTime = new IntegerValue(
            this.resyncGroup,
            "Resync Hurt Time",
            "The amount of hurttime in ticks to resync on damage.",
            5,
            1,
            9).visibleCondition(this.resyncOnDamage::getValue);

    private final BooleanValue resyncOnWorldChange = new BooleanValue(
            this.resyncGroup,
            "Resync on World Change",
            "Resync if the world changes.",
            true);

    private final BooleanValue resyncOnRespawn = new BooleanValue(
            this.resyncGroup,
            "Resync on Respawn",
            "Resync if you respawn.",
            true);

    private final BooleanValue resyncOnTeleport = new BooleanValue(
            this.resyncGroup,
            "Resync on Teleport",
            "Resync if the setver teleports you.",
            true);

    private final TrackedPosition serverPosition = new TrackedPosition();

    private final ConcurrentLinkedQueue<DelayedPacket> packets = new ConcurrentLinkedQueue<>();

    private final MSTimer packetDropTimer = new MSTimer();

    public FakeLagModule() {
        super(
                "Fake Lag",
                "You seem to lag for other players.",
                Category.EXPLOIT
        );
    }

    @Override
    public void onActivate() {
        Vandalism.getInstance().getEventSystem().subscribe(
                this,
                PlayerUpdateEvent.ID,
                Render3DEvent.ID,
                WorldLoadEvent.ID,
                IncomingPacketEvent.ID
        );

        Vandalism.getInstance().getEventSystem().subscribe(
                OutgoingPacketEvent.ID,
                this,
                Priorities.HIGH
        );

        handlePackets(true);
        this.packets.clear();
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(
                this,
                PlayerUpdateEvent.ID,
                OutgoingPacketEvent.ID,
                Render3DEvent.ID,
                WorldLoadEvent.ID,
                IncomingPacketEvent.ID
        );
    }

    @Override
    public void onPrePlayerUpdate(final PlayerUpdateEvent event) {
        if (this.resyncOnDamage.getValue() && this.mc.player.hurtTime >= this.resyncHurtTime.getValue()) {
            this.handlePackets(true);
            this.packetDropTimer.reset();
        }

        if (this.packetDropTimer.hasReached(this.packetDrop.getValue(), true)) {
            this.handlePackets(false);
        }
    }

    @Override
    public void onOutgoingPacket(final OutgoingPacketEvent event) {
        if (this.mc.player == null) {
            handlePackets(true);
            return;
        }

        event.cancel();

        if (this.dropPacketChance.getValue() > 0 && RandomUtils.randomInt(0, 100) < this.dropPacketChance.getValue()) {
            return;
        }

        final long now = System.currentTimeMillis();
        this.packets.add(new DelayedPacket(event.packet, now));

        if (this.duplicatePacketChance.getValue() > 0 && RandomUtils.randomInt(0, 100) < this.duplicatePacketChance.getValue()) {
            this.packets.add(new DelayedPacket(event.packet, now));
        }
    }

    @Override
    public void onIncomingPacket(IncomingPacketEvent event) {
        if (this.mc.player == null) {
            return;
        }

        if (event.packet instanceof PlayerRespawnS2CPacket && this.resyncOnRespawn.getValue()) {
            handlePackets(true);
            this.packetDropTimer.reset();
        }

        if (event.packet instanceof PlayerPositionLookS2CPacket && this.resyncOnTeleport.getValue()) {
            handlePackets(true);
            this.packetDropTimer.reset();
        }
    }

    @Override
    public void onPreWorldLoad() {
        if (this.resyncOnWorldChange.getValue()) {
            handlePackets(true);
            this.packetDropTimer.reset();
        }
    }

    @Override
    public void onRender3D(final float tickDelta, final long limitTime, final MatrixStack matrixStack) {
        if (this.serverPosition == null) {
            return;
        }

        final Vec3d pos = this.serverPosition.pos;
        if (pos.distanceTo(mc.player.getPos()) < 0.1) {
            return;
        }

        matrixStack.push();

        final Box box = new Box(
                pos.x - mc.player.getWidth() / 2f,
                pos.y,
                pos.z - mc.player.getWidth() / 2f,
                pos.x + mc.player.getWidth() / 2f,
                pos.y + mc.player.getHeight(),
                pos.z + mc.player.getWidth() / 2f
        );

        final Vec3d center = box.getCenter();
        final double scale = 1.5;

        final Vec3d camPos = this.mc.gameRenderer.getCamera().getPos();
        matrixStack.translate(-camPos.x, -camPos.y, -camPos.z);

        final VertexConsumerProvider.Immediate immediate = VertexConsumerProvider.immediate(Tessellator.getInstance().getBuffer());

        matrixStack.push();
        final double minX = (box.minX - center.x) * scale + center.x;
        final double minZ = (box.minZ - center.z) * scale + center.z;
        final double maxX = (box.maxX - center.x) * scale + center.x;
        final double maxZ = (box.maxZ - center.z) * scale + center.z;
        DebugRenderer.drawBox(
                matrixStack,
                immediate,
                minX, box.minY, minZ, maxX, box.maxY, maxZ,
                1.0f, 0.0f, 0.0f, 0.4f
        );
        matrixStack.pop();

        immediate.draw();

        matrixStack.pop();
    }

    //@formatter:off
    private record DelayedPacket(Packet<?> packet, long time) {}
    //@formatter:on

    private void handlePackets(final boolean flush) {
        for (final DelayedPacket delayedPacket : this.packets) {
            if (flush || System.currentTimeMillis() > delayedPacket.time() + this.packetDelay.getValue()) {
                final Packet<?> packet = delayedPacket.packet();

                if (packet instanceof final PlayerMoveC2SPacket moveC2SPacket) {
                    this.serverPosition.setPos(new Vec3d(
                            moveC2SPacket.getX(this.serverPosition.pos.x),
                            moveC2SPacket.getY(this.serverPosition.pos.y),
                            moveC2SPacket.getZ(this.serverPosition.pos.z)));
                }

                PacketUtil.sendImmediately(packet, null, true);
                this.packets.remove(delayedPacket);
            }
        }
    }

}
