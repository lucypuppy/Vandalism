/*
 * This file is part of Vandalism - https://github.com/NekosAreKawaii/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, FooFieOwO, Verschlxfene, Recyz and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit.exploitfixer;

import com.google.common.collect.ImmutableMap;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.feature.module.impl.misc.ResourcePackSpooferModule;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.resource.DefaultClientResourcePackProvider;
import net.minecraft.resource.*;
import net.minecraft.text.*;
import net.minecraft.util.Language;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;

public class ComponentResolverContainer {

    private static final String DEFAULT_LANGUAGE = "en_us";
    private static LoadedLanguage language;
    private static final DefaultResourcePack DEFAULT_RESOURCE_PACK;

    static {
        final DefaultClientResourcePackProvider defaultClientResourcePackProvider = new DefaultClientResourcePackProvider(Vandalism.getInstance().getRunArgs().directories.getAssetDir(), MinecraftClient.getInstance().getSymlinkFinder());
        DEFAULT_RESOURCE_PACK = defaultClientResourcePackProvider.getResourcePack();
        ComponentResolverContainer.load(ComponentResolverContainer.DEFAULT_LANGUAGE);
    }

    public static void load(final String language) {
        final ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();

        ComponentResolverContainer.computeResourcePack(ComponentResolverContainer.DEFAULT_RESOURCE_PACK, language, builder::put);

        ComponentResolverContainer.language = new LoadedLanguage(language, builder.build());
    }

    public static String update() {
        final String currentLanguage = MinecraftClient.getInstance().getLanguageManager().getLanguage();
        if (!currentLanguage.equals(ComponentResolverContainer.language.name)) {
            ComponentResolverContainer.load(currentLanguage);
        }
        return currentLanguage;
    }

    public static Map<String, String> apply(final Iterable<ResourcePack> packs, final Iterable<ResourcePackSpooferModule.PackEntry> spoofedPacks) {
        final String currentLanguage = ComponentResolverContainer.update();
        final Map<String, String> map = new HashMap<>(ComponentResolverContainer.language.translations);
        for (final ResourcePack pack : packs) {
            ComponentResolverContainer.computeResourcePack(pack, currentLanguage, map::put);
        }

        for (final ResourcePackSpooferModule.PackEntry pack : spoofedPacks) {
            if (pack.translations.containsKey(currentLanguage)) {
                map.putAll(pack.translations.get(currentLanguage));
            }
        }

        return map;
    }

    public static void computeResourcePack(final ResourcePack pack, final String language, final BiConsumer<String, String> consumer) {
        final Set<String> namespaces = pack.getNamespaces(ResourceType.CLIENT_RESOURCES);
        for (final String namespace : namespaces) {
            final InputSupplier<InputStream> supplier = pack.openRoot("assets", namespace, "lang", language.concat(".json"));
            if (supplier != null) {
                try {
                    Language.load(supplier.get(), consumer);
                } catch (final IOException ignored) {
                }
            }
        }
    }

    public static boolean containsTranslation(final Iterable<ResourcePack> resourcePacks, final Iterable<ResourcePackSpooferModule.PackEntry> spoofedPacks, final String key) {
        return ComponentResolverContainer.apply(resourcePacks, spoofedPacks).containsKey(key);
    }

    public static List<ResourcePack> getResourcePacks() {
        return MinecraftClient.getInstance().getResourcePackManager().getEnabledProfiles().stream().filter(profile -> profile.getSource() == ResourcePackSource.SERVER).map(ResourcePackProfile::createResourcePack).collect(Collectors.toList());
    }

    public static Text compute(final Text text) {
        return ComponentResolverContainer.compute(text, null);
    }

    public static Text compute(final Text text, List<ResourcePack> packs) {
        final MutableText mutable = switch (text.getContent()) {
            case final TranslatableTextContent translatable -> {
                final Object[] args = translatable.getArgs();
                final Object[] newArgs = new Object[args.length];
                for (int i = 0; i < args.length; i++) {
                    Object arg = args[i];
                    if (arg instanceof final Text argText) {
                        arg = ComponentResolverContainer.compute(argText, packs);
                    }
                    newArgs[i] = arg;
                }

                if (packs == null) {
                    packs = ComponentResolverContainer.getResourcePacks();
                }

                final String key = translatable.getKey();
                final String fallback = translatable.getFallback();

                final Language language = Language.getInstance();
                final Map<String, String> translations = ComponentResolverContainer.apply(packs, Vandalism.getInstance().getModuleManager().getResourcePackSpooferModule().getActivatedPacks());

                yield translations.containsKey(key) ? MutableText.of(new TranslatableTextContent(translations.get(key), fallback, newArgs)) : (language.hasTranslation(key) ? MutableText.of(PlainTextContent.of(fallback == null ? key : fallback)) : MutableText.of(new TranslatableTextContent(key, translatable.getFallback(), newArgs)));
            }

            case final KeybindTextContent keybind -> {
                if (packs == null) {
                    packs = ComponentResolverContainer.getResourcePacks();
                }

                final String key = keybind.getKey();
                final Language language = Language.getInstance();
                final Map<String, String> translations = ComponentResolverContainer.apply(packs, Vandalism.getInstance().getModuleManager().getResourcePackSpooferModule().getActivatedPacks());

                yield translations.containsKey(key) ? MutableText.of(new KeybindTextContent(translations.get(key))) : (language.hasTranslation(key) ? MutableText.of(PlainTextContent.of(key)) : MutableText.of(new KeybindTextContent(key)));
            }
            default -> MutableText.of(text.getContent());
        };

        for (final Text sibling : text.getSiblings()) {
            mutable.append(ComponentResolverContainer.compute(sibling, packs));
        }

        return mutable;
    }

    public record LoadedLanguage(String name, Map<String, String> translations) {
    }
}
