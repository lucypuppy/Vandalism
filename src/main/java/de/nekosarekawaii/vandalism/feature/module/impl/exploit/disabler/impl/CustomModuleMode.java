/*
 * This file is part of Vandalism - https://github.com/NekosAreKawaii/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, FooFieOwO, Recyz and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit.disabler.impl;

import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
import de.florianmichael.viafabricplus.protocoltranslator.ProtocolTranslator;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.number.LongValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.BooleanValue;
import de.nekosarekawaii.vandalism.base.value.template.ValueGroup;
import de.nekosarekawaii.vandalism.event.network.OutgoingPacketListener;
import de.nekosarekawaii.vandalism.event.player.PlayerUpdateListener;
import de.nekosarekawaii.vandalism.feature.module.impl.exploit.disabler.DisablerModule;
import de.nekosarekawaii.vandalism.feature.module.template.module.ModuleMulti;
import de.nekosarekawaii.vandalism.integration.ViaFabricPlusAccess;
import de.nekosarekawaii.vandalism.util.PacketHelper;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;

import java.util.concurrent.ConcurrentHashMap;

public class CustomModuleMode extends ModuleMulti<DisablerModule> implements OutgoingPacketListener, PlayerUpdateListener {

    private int parameter, ticksSincePong;
    private final ConcurrentHashMap<Packet<?>, Long> packets = new ConcurrentHashMap<>();

    public CustomModuleMode() {
        super("Custom");
    }

    private final ValueGroup pongGroup = new ValueGroup(this, "Transaction", "Change transaction behaviour.");
    private final BooleanValue cancelPong = new BooleanValue(pongGroup, "Cancel Transaction", "Cancels the transaction packets.", false);
    private final BooleanValue pongDeSync = new BooleanValue(pongGroup, "Transaction Desync", "Desyncs your transaction packets.", false).visibleCondition(() -> !cancelPong.getValue());
    private final IntegerValue ticksUntilPong = new IntegerValue(pongGroup, "Ticks until Transaction", "The amount of ticks until the transaction packet is sent.", 50, 0, 100).visibleCondition(() -> !cancelPong.getValue() && pongDeSync.getValue());
    private final BooleanValue negativePong = new BooleanValue(pongGroup, "Negative Transaction", "Negate your sent transaction ids.", false).visibleCondition(() -> !cancelPong.getValue());

    private final ValueGroup keepAliveGroup = new ValueGroup(this, "Keep Alive", "Change keep alive behaviour.");
    private final BooleanValue cancelKeepAlive = new BooleanValue(keepAliveGroup, "Cancel Keep Alive", "Cancels the Keep Alive packets.", false);
    private final BooleanValue delayKeepAlive = new BooleanValue(keepAliveGroup, "Delay Keep Alive", "Delays the Keep Alive packets.", false).visibleCondition(() -> !cancelKeepAlive.getValue());
    private final LongValue keepAliveDelay = new LongValue(keepAliveGroup, "Keep Alive Delay", "The amount of delay to wait before sending the packets.", 5000L, 0L, 25000L).visibleCondition(() -> !cancelKeepAlive.getValue() && delayKeepAlive.getValue());

    private final ValueGroup onGroundGroup = new ValueGroup(this, "OnGround", "Change onGround behaviour.");
    private final BooleanValue bypassMathOnGround = new BooleanValue(onGroundGroup, "Bypass Math onGround", "Bypasses a simple mathematical onGround check.", false);
    private final BooleanValue spoofOnGround = new BooleanValue(onGroundGroup, "Spoof onGround", "Spoofs the onGround value.", false);
    private final BooleanValue onGroundValue = new BooleanValue(onGroundGroup, "OnGround Value", "The value to set onGround to.", false).visibleCondition(spoofOnGround::getValue);

    private final BooleanValue waterBucketDisabler = new BooleanValue(this, "Place Water Bucket", "Sends a place block packet using a water bucket. (1.8.x)", false).visibleCondition(() -> ProtocolTranslator.getTargetVersion() == ProtocolVersion.v1_8);

    @Override
    public void onActivate() {
        Vandalism.getInstance().getEventSystem().subscribe(this, OutgoingPacketEvent.ID, PlayerUpdateEvent.ID);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(this, OutgoingPacketEvent.ID, PlayerUpdateEvent.ID);
    }

    @Override
    public void onOutgoingPacket(OutgoingPacketEvent event) {
        if (mc.getNetworkHandler() == null || mc.getNetworkHandler().getConnection() == null || mc.player == null || mc.player.age == 0) {
            packets.clear();
            return;
        }

        if (event.packet instanceof final CommonPongC2SPacket packet) {
            boolean canDeSync = pongDeSync.isVisible().getAsBoolean() && pongDeSync.getValue();

            if (canDeSync && parameter <= 0) {
                parameter = packet.getParameter();
            }

            if(negativePong.getValue()) {
                event.packet = new CommonPongC2SPacket(-parameter);
            }

            if (canDeSync || cancelPong.getValue())
                event.cancel();
        }

        if (event.packet instanceof KeepAliveC2SPacket) {
            boolean canDelay = delayKeepAlive.isVisible().getAsBoolean() && delayKeepAlive.getValue();

            if(canDelay)
                packets.put(event.packet, System.currentTimeMillis());

            if(canDelay || cancelKeepAlive.getValue())
                event.cancel();
        }

        if (event.packet instanceof final PlayerMoveC2SPacket packet) {
            if(bypassMathOnGround.getValue()) {
                packet.y = Math.round(packet.y / 0.015625) * 0.015625;
            }
            if(spoofOnGround.getValue()) {
                packet.onGround = onGroundValue.getValue();
            }
        }
    }

    @Override
    public void onPrePlayerUpdate(PlayerUpdateEvent event) {
        if(pongDeSync.isVisible().getAsBoolean() && pongDeSync.getValue()) {
            ticksSincePong++;

            if (parameter > 100 && ticksSincePong > ticksUntilPong.getValue()) {
                parameter++;
                PacketHelper.sendImmediately(new CommonPongC2SPacket(negativePong.getValue() ? -parameter : parameter), null, true);
                ticksSincePong = 0;
            }
        }

        if(waterBucketDisabler.getValue()) {
            if (ProtocolTranslator.getTargetVersion() == ProtocolVersion.v1_8 && mc.player.age % 4 == 0) {
                ViaFabricPlusAccess.send1_8BlockPlacePacket(mc.player.getBlockPos(), 255, new ItemStack(Items.WATER_BUCKET), 0, 0.5f, 0);
            }
        }

        if(delayKeepAlive.isVisible().getAsBoolean() && delayKeepAlive.getValue()) {
            for (final Packet<?> packet : packets.keySet()) {
                if (System.currentTimeMillis() - packets.get(packet) >= keepAliveDelay.getValue()) {
                    packets.remove(packet);
                    PacketHelper.sendImmediately(packet, null, true);
                }
            }
        }
    }
}
