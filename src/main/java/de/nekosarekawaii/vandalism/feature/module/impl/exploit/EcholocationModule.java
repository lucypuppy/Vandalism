/*
 * This file is part of Vandalism - https://github.com/VandalismDevelopment/Vandalism
 * Copyright (C) 2023-2024 NekosAreKawaii, Verschlxfene, FooFieOwO and contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.nekosarekawaii.vandalism.feature.module.impl.exploit;

import de.florianmichael.rclasses.math.Percentage;
import de.florianmichael.rclasses.math.timer.MSTimer;
import de.nekosarekawaii.vandalism.Vandalism;
import de.nekosarekawaii.vandalism.base.value.impl.number.IntegerValue;
import de.nekosarekawaii.vandalism.event.cancellable.network.IncomingPacketListener;
import de.nekosarekawaii.vandalism.event.normal.player.PlayerUpdateListener;
import de.nekosarekawaii.vandalism.feature.module.AbstractModule;
import de.nekosarekawaii.vandalism.util.game.ChatUtil;
import net.minecraft.block.entity.BlockEntityType;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.network.packet.c2s.play.UpdateSignC2SPacket;
import net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;
import java.util.List;

public class EcholocationModule extends AbstractModule implements PlayerUpdateListener, IncomingPacketListener {

    private final IntegerValue maxPacketsPerTick = new IntegerValue(
            this,
            "Max Packets Per Tick",
            "The maximum amount of packets sent per tick.",
            1,
            1,
            10000
    );

    private final IntegerValue delay = new IntegerValue(
            this,
            "Delay",
            "The delay between packets.",
            0,
            0,
            2000
    );

    private final IntegerValue startX = new IntegerValue(
            this,
            "Start X",
            "The X coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue startY = new IntegerValue(
            this,
            "Start Y",
            "The Y coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue startZ = new IntegerValue(
            this,
            "Start Z",
            "The Z coordinate to start from.",
            0,
            -1000,
            1000
    );

    private final IntegerValue endX = new IntegerValue(
            this,
            "End X",
            "The X coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final IntegerValue endY = new IntegerValue(
            this,
            "End Y",
            "The Y coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final IntegerValue endZ = new IntegerValue(
            this,
            "End Z",
            "The Z coordinate to end at.",
            1000,
            -1000,
            1000
    );

    private final MSTimer delayTimer = new MSTimer();

    private final List<BlockPos> possibleBlockPositions = new ArrayList<>();
    private int lastChecked = -2;

    private Thread scanThread = null;

    public EcholocationModule() {
        super(
                "Echolocation",
                "This module allows you to find loaded chunks via. sign update packets on the server (Vanilla/Spigot).",
                Category.EXPLOIT
        );
        this.deactivateAfterSessionDefault();
    }

    private void reset() {
        this.lastChecked = -2;
        this.possibleBlockPositions.clear();
        try {
            if (this.scanThread != null) {
                this.scanThread.interrupt();
                this.scanThread.stop();
                this.scanThread = null;
            }
        } catch (Exception ignored) {
        }
    }

    @Override
    public void onActivate() {
        this.reset();
        this.scanThread = new Thread(() -> {
            ChatUtil.warningChatMessage("Echolocation: Started thread to add all possible block positions to the list.");
            for (int currentX = this.startX.getValue(); currentX < this.endX.getValue(); currentX++) {
                for (int currentY = this.startY.getValue(); currentY < this.endY.getValue(); currentY++) {
                    for (int currentZ = this.startZ.getValue(); currentZ < this.endZ.getValue(); currentZ++) {
                        this.possibleBlockPositions.add(new BlockPos(currentX, currentY, currentZ));
                    }
                }
            }
            ChatUtil.infoChatMessage("Echolocation: Finished adding all possible block positions to the list.");
            this.lastChecked = -1;
        });
        this.scanThread.start();
        Vandalism.getInstance().getEventSystem().subscribe(PlayerUpdateEvent.ID, this);
        Vandalism.getInstance().getEventSystem().subscribe(IncomingPacketEvent.ID, this);
    }

    @Override
    public void onDeactivate() {
        Vandalism.getInstance().getEventSystem().unsubscribe(PlayerUpdateEvent.ID, this);
        Vandalism.getInstance().getEventSystem().unsubscribe(IncomingPacketEvent.ID, this);
        this.reset();
    }

    @Override
    public void onPrePlayerUpdate(final PlayerUpdateEvent event) {
        if (this.lastChecked != -2 && this.delayTimer.hasReached(this.delay.getValue(), true)) {
            for (int i = 0; i < this.maxPacketsPerTick.getValue(); i++) {
                this.lastChecked++;
                if (this.lastChecked >= this.possibleBlockPositions.size()) {
                    this.reset();
                    ChatUtil.infoChatMessage("Echolocation: Finished with checking all possible block positions.");
                    this.deactivate();
                    break;
                }
                final BlockPos blockPos = this.possibleBlockPositions.get(this.lastChecked);
                ChatUtil.infoChatMessage("Echolocation: " + blockPos.toShortString() + " | " + Percentage.percentage(this.lastChecked, this.possibleBlockPositions.size()) + "%");
                final String text = "";
                this.mc.getNetworkHandler().getConnection().send(new UpdateSignC2SPacket(blockPos, true, text, text, text, text), null, true);
            }
        }
    }

    @Override
    public void onIncomingPacket(final IncomingPacketEvent event) {
        if (this.lastChecked == -2) return;
        if (event.packet instanceof final BlockEntityUpdateS2CPacket blockEntityUpdateS2CPacket) {
            if (blockEntityUpdateS2CPacket.getBlockEntityType().getRegistryEntry().equals(BlockEntityType.SIGN.getRegistryEntry())) {
                final NbtCompound nbt = blockEntityUpdateS2CPacket.getNbt();
                if (!nbt.isEmpty()) {
                    final StringBuilder text = new StringBuilder();
                    text.append(" (");
                    text.append(blockEntityUpdateS2CPacket.getPos().toShortString());
                    text.append(")");
                    text.append(" [");
                    if (nbt.contains("back_text")) {
                        final NbtCompound backText = nbt.getCompound("back_text");
                        if (backText.contains("messages")) {
                            final NbtList messages = backText.getList("messages", 8);
                            text.append("Back Messages: ");
                            for (int i = 0; i < messages.size(); i++) {
                                final String message = messages.getString(i);
                                text.append(message);
                                if (i != messages.size() - 1) {
                                    text.append(", ");
                                }
                            }
                            text.append(" | ");
                        }
                    }
                    if (nbt.contains("front_text")) {
                        final NbtCompound frontText = nbt.getCompound("front_text");
                        if (frontText.contains("messages")) {
                            final NbtList messages = frontText.getList("messages", 8);
                            text.append("Front Messages: ");
                            for (int i = 0; i < messages.size(); i++) {
                                final String message = messages.getString(i);
                                text.append(message);
                                if (i != messages.size() - 1) {
                                    text.append(", ");
                                }
                            }
                        }
                    }
                    text.append("]");
                    ChatUtil.infoChatMessage("Found loaded sign: " + text);
                }
            }
        }
    }

}
